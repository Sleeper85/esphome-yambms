# Updated : 2026.02.02
# Version : 1.7.0
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

substitutions:
  yambms_version: "1.7.0"

globals:
  # BMS
  - id: ${yambms_id}_var_bms_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_to_combine_bms_number
    type: int
    restore_value: no
    initial_value: '1'
  - id: ${yambms_id}_var_to_combine_bms_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_bms_online_bitmask
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_bms_seen_online_bitmask
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_errors_bitmask_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_errors_bitmask
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_equalizing_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_charging_allowed_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_discharging_allowed_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_bms_blocking_charge_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_bms_blocking_discharge_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_min_voltage_cell
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_max_voltage_cell
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_min_cell_voltage
    type: float
    restore_value: no
    initial_value: '5.0'
  - id: ${yambms_id}_var_max_cell_voltage
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_total_max_charge_current
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_total_max_discharge_current
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_total_installed_battery_capacity
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_total_battery_capacity
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_total_battery_capacity_remaining
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_total_charging_cycles
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_min_cell_ovp
    type: float
    restore_value: no
    initial_value: '5.0'
  - id: ${yambms_id}_var_max_cell_uvp
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_max_balance_trigger_voltage
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_min_temperature
    type: float
    restore_value: no
    initial_value: '100.0'
  - id: ${yambms_id}_var_min_temperature_sensor
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_max_temperature
    type: float
    restore_value: no
    initial_value: '-100.0'
  - id: ${yambms_id}_var_max_temperature_sensor
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_bms_total_voltage
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_bms_total_current
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_bms_total_power
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_bms_total_soc
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_bms_total_soh
    type: float
    restore_value: no
    initial_value: '0.0'
  # Shunt
  - id: ${yambms_id}_var_shunt_use
    type: bool
    restore_value: no
    initial_value: "false"
  - id: ${yambms_id}_var_shunt_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_to_combine_shunt_number
    type: int
    restore_value: no
    initial_value: '1'
  - id: ${yambms_id}_var_to_combine_shunt_counter
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_shunt_total_voltage
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_shunt_total_current
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_shunt_total_power
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_shunt_total_soc
    type: float
    restore_value: no
    initial_value: '0.0'
  # YamBMS
  - id: ${yambms_id}_var_service
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: ${yambms_id}_var_initialized
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${yambms_id}_var_requested_ccl_init
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${yambms_id}_var_requested_dcl_init
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${yambms_id}_var_bms_charging_logic
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${yambms_id}_var_force_bulk
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${yambms_id}_var_force_float
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${yambms_id}_var_charge_status
    type: std::string
    restore_value: no
    initial_value: '"Init"'
  - id: ${yambms_id}_var_inverter_bms_name
    type: std::string
    restore_value: no
  - id: ${yambms_id}_var_inverter_protocol
    type: std::string
    restore_value: no
  - id: ${yambms_id}_var_cell_nominal_v
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_cell_min_charge_v
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_cell_max_charge_v
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_cell_max_discharge_v
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_charge_current_step
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_discharge_current_step
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_auto_ccl_functions_count
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_auto_dcl_functions_count
    type: int
    restore_value: no
    initial_value: '0'
  - id: ${yambms_id}_var_auto_cvl
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_auto_ccl
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_auto_dcl
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_auto_temperature_ccl
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_auto_temperature_dcl
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_auto_eoc
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_auto_float
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: ${yambms_id}_var_eoc
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ${yambms_id}_var_eoc_timestamp
    type: time_t
    restore_value: true
    initial_value: ''

# Execute once
esphome:
  on_boot:
    then:
      - lambda: |-
          //
          // Source : https://batteryuniversity.com/article/bu-216-summary-table-of-lithium-based-batteries
          //
          if (${yambms_battery_chemistry} == 1) // LFP
          {
            // LFP
            id(${yambms_id}_var_cell_nominal_v) = 3.20;
            id(${yambms_id}_var_cell_min_charge_v) = 3.37; // Fully charged at rest
            id(${yambms_id}_var_cell_max_charge_v) = 3.65;
            id(${yambms_id}_var_cell_max_discharge_v) = 3.00; // Not used
          }
          else if (${yambms_battery_chemistry} == 2) // Li-ion
          {
            // Li-ion
            id(${yambms_id}_var_cell_nominal_v) = 3.60;
            id(${yambms_id}_var_cell_min_charge_v) = 3.90;
            id(${yambms_id}_var_cell_max_charge_v) = 4.20;
            id(${yambms_id}_var_cell_max_discharge_v) = 3.20; // Not used
          }
          else if (${yambms_battery_chemistry} == 3) // LTO
          {
            // LTO
            id(${yambms_id}_var_cell_nominal_v) = 2.40;
            id(${yambms_id}_var_cell_min_charge_v) = 2.55; // Fully charged at rest
            id(${yambms_id}_var_cell_max_charge_v) = 2.85;
            id(${yambms_id}_var_cell_max_discharge_v) = 2.00; // Not used
          }
          int cell_count = ${yambms_cell_count};
          // Bulk V.
          id(${yambms_id}_bulk_voltage).traits.set_min_value(round(cell_count * id(${yambms_id}_var_cell_min_charge_v) * 10) / 10);
          id(${yambms_id}_bulk_voltage).traits.set_max_value(round(cell_count * id(${yambms_id}_var_cell_max_charge_v) * 10) / 10);
          // Float V.
          id(${yambms_id}_float_voltage).traits.set_min_value(round(cell_count * (id(${yambms_id}_var_cell_min_charge_v) - 0.15) * 10) / 10);
          id(${yambms_id}_float_voltage).traits.set_max_value(round(cell_count * (id(${yambms_id}_var_cell_min_charge_v) + 0.05) * 10) / 10);
          // Rebulk V.
          id(${yambms_id}_rebulk_voltage).traits.set_min_value(round(cell_count * id(${yambms_id}_var_cell_nominal_v) * 10) / 10);
          id(${yambms_id}_rebulk_voltage).traits.set_max_value(round(cell_count * id(${yambms_id}_var_cell_min_charge_v) * 10) / 10);

# YamBMS core lambda
interval:
  - interval: ${yambms_update_interval}
    then:
      - lambda: |-
          // +-----------------------------------------------+
          // | STEP 2 - YamBMS combiner                      |
          // +-----------------------------------------------+
          // If all device have communicated their informations
          int device_counter = (id(${yambms_id}_var_bms_counter) + id(${yambms_id}_var_shunt_counter));
          int processed_device_counter = (id(${yambms_id}_var_to_combine_bms_number) + id(${yambms_id}_var_to_combine_shunt_number));
          if ((device_counter + 2) == processed_device_counter)
          {
            // No combined BMS > YamBMS need to be re-initialized
            if (id(${yambms_id}_var_to_combine_bms_counter) == 0)
            {
              id(${yambms_id}_var_initialized) = false;
              id(${yambms_id}_var_requested_ccl_init) = false;
              id(${yambms_id}_var_requested_dcl_init) = false;
            }
            
            // +-----------------------------------------------+
            // | Errors bitmask (JK 16bit)                     |
            // +-----------------------------------------------+

            // Alarm - all BMS are in alarm ?
            if (id(${yambms_id}_var_errors_bitmask_counter) == id(${yambms_id}_var_bms_counter))
            {
              id(${yambms_id}_errors_bitmask_alarm).publish_state(id(${yambms_id}_var_errors_bitmask));
            }
            // At least one BMS is not in alarm
            else id(${yambms_id}_errors_bitmask_alarm).publish_state(0);
            // Warning
            id(${yambms_id}_errors_bitmask_warning).publish_state(id(${yambms_id}_var_errors_bitmask));
            // errors_bitmask_counter ( number of BMS in alarms)
            id(${yambms_id}_errors_bitmask_counter).publish_state(id(${yambms_id}_var_errors_bitmask_counter));

            // +-----------------------------------------------+
            // | Voltage, Current, Power, SOC, SOH, Ch. Cycles |
            // +-----------------------------------------------+

            // Vars init
            float total_voltage = 0.0;
            float current = 0.0;
            int power = 0;
            int battery_charging_power = 0;
            int battery_discharging_power = 0;
            int soc = 0;
            int soh = 0;
            int charging_cycles = 0;

            // +-----------------------------------------------+
            // | At least one BMS can be combined              |
            // +-----------------------------------------------+
            if (id(${yambms_id}_var_to_combine_bms_counter) > 0)
            {
              // MEAN total_voltage (Shunt/BMS)
              if (id(${yambms_id}_var_shunt_use) == true)
                total_voltage = (id(${yambms_id}_var_shunt_total_voltage) / id(${yambms_id}_var_to_combine_shunt_counter));
              else
                total_voltage = (id(${yambms_id}_var_bms_total_voltage) / id(${yambms_id}_var_to_combine_bms_counter));

              // TOTAL current (Shunt/BMS)
              if (id(${yambms_id}_var_shunt_use) == true)
                current = id(${yambms_id}_var_shunt_total_current);
              else
                current = id(${yambms_id}_var_bms_total_current);

              // TOTAL power (Shunt/BMS)
              if (id(${yambms_id}_var_shunt_use) == true)
                power = round(id(${yambms_id}_var_shunt_total_power));
              else
                power = round(id(${yambms_id}_var_bms_total_power));

              // battery_charging_power           
              if (power > 0)
                battery_charging_power = power;
              
              // battery_discharging_power
              if (power <= 0)
                battery_discharging_power = power * -1; // Must be positive energy
              
              // MEAN Battery SOC (Shunt/BMS)
              if (id(${yambms_id}_var_shunt_use) == true)
                soc = round(id(${yambms_id}_var_shunt_total_soc) / id(${yambms_id}_var_to_combine_shunt_counter));
              else
                soc = round(id(${yambms_id}_var_total_battery_capacity_remaining) / id(${yambms_id}_var_total_battery_capacity) * 100);

              // SOC manipulation
              if (id(${yambms_id}_var_to_combine_bms_counter) == 0) soc = 0;      // no BMS combined => sending 0%
              else if ((soc > 98) && (id(${yambms_id}_var_eoc) == false)) soc = 98;   // Useful for some inverters stopping charging when SoC reaches 100%

              // MEAN Battery SOH
              soh = round(id(${yambms_id}_var_bms_total_soh) / id(${yambms_id}_var_to_combine_bms_counter));

              // MEAN charging_cycles
              charging_cycles = round(id(${yambms_id}_var_total_charging_cycles) / id(${yambms_id}_var_to_combine_bms_counter));
            }

            // Publishing sensors
            id(${yambms_id}_total_voltage).publish_state(total_voltage);
            id(${yambms_id}_current).publish_state(current);
            id(${yambms_id}_power).publish_state(power);
            id(${yambms_id}_battery_charging_power).publish_state(battery_charging_power);
            id(${yambms_id}_battery_discharging_power).publish_state(battery_discharging_power);
            id(${yambms_id}_battery_soc).publish_state(soc);
            id(${yambms_id}_battery_soh).publish_state(soh);
            id(${yambms_id}_charging_cycles).publish_state(charging_cycles);

            // +-----------------------------------------------+
            // | TOTAL battery_capacity                        |
            // +-----------------------------------------------+
            float battery_capacity = id(${yambms_id}_var_total_battery_capacity);
            id(${yambms_id}_battery_capacity).publish_state(round(battery_capacity));

            // +-----------------------------------------------+
            // | TOTAL battery_capacity_remaining              |
            // +-----------------------------------------------+
            float capacity_remaining = id(${yambms_id}_var_total_battery_capacity_remaining);

            if (id(${yambms_id}_var_shunt_use) == true)
              capacity_remaining = battery_capacity / 100 * soc;
            
            id(${yambms_id}_battery_capacity_remaining).publish_state(round(capacity_remaining));

            // +-----------------------------------------------+
            // | Max charge current                            |
            // +-----------------------------------------------+
            int cc_step = id(${yambms_id}_var_charge_current_step);
            if (cc_step == 0 || cc_step == id(${yambms_id}_var_auto_ccl_functions_count) + 2)
            {
              ESP_LOGD("yambms_debug", "Entering Max charge current...");

              float max_charge_current = 0.0;

              if (id(${yambms_id}_var_to_combine_bms_counter) > 0)
              {
                float max_charge_current_yambms = id(${yambms_id}_max_requested_charge_current).state;
                float max_charge_current_bms = id(${yambms_id}_var_total_max_charge_current) * 0.9;

                if (max_charge_current_bms > max_charge_current_yambms)
                  max_charge_current = max_charge_current_yambms;
                else
                  max_charge_current = max_charge_current_bms;

                ESP_LOGD("yambms_debug", "Max charge current YamBMS : %f A", max_charge_current_yambms);
                ESP_LOGD("yambms_debug", "Max charge current BMS : %f A", max_charge_current_bms);
              }
              id(${yambms_id}_max_charge_current).publish_state(round(max_charge_current));
              id(${yambms_id}_var_charge_current_step) = 1;
              ESP_LOGD("yambms_debug", "Max charge current : %f A", max_charge_current);

            }

            // +-----------------------------------------------+
            // | Max discharge current                         |
            // +-----------------------------------------------+
            int dc_step = id(${yambms_id}_var_discharge_current_step);
            if (dc_step == 0 || dc_step == id(${yambms_id}_var_auto_dcl_functions_count) + 2)
            {
              ESP_LOGD("yambms_debug", "Entering Max discharge current...");

              float max_discharge_current = 0.0;

              if (id(${yambms_id}_var_to_combine_bms_counter) > 0)
              {
                float max_discharge_current_yambms = id(${yambms_id}_max_requested_discharge_current).state;
                float max_discharge_current_bms = id(${yambms_id}_var_total_max_discharge_current) * 0.9;

                if (max_discharge_current_bms > max_discharge_current_yambms)
                  max_discharge_current = max_discharge_current_yambms;
                else
                  max_discharge_current = max_discharge_current_bms;

                ESP_LOGD("yambms_debug", "Max discharge current YamBMS : %f A", max_discharge_current_yambms);
                ESP_LOGD("yambms_debug", "Max discharge current BMS : %f A", max_discharge_current_bms);
              }
              id(${yambms_id}_max_discharge_current).publish_state(round(max_discharge_current));
              id(${yambms_id}_var_discharge_current_step) = 1;
              ESP_LOGD("yambms_debug", "Max discharge current : %f A", max_discharge_current);
            }

            // +-----------------------------------------------+
            // | MAX balance_trigger_voltage                   |
            // +-----------------------------------------------+
            id(${yambms_id}_balance_trigger_voltage).publish_state(id(${yambms_id}_var_max_balance_trigger_voltage));

            // +-----------------------------------------------+
            // | MIN min_cell_voltage                          |
            // | MIN min_voltage_cell (cell number)            |
            // +-----------------------------------------------+
            id(${yambms_id}_min_cell_voltage).publish_state(id(${yambms_id}_var_min_cell_voltage));
            id(${yambms_id}_min_voltage_cell).publish_state(id(${yambms_id}_var_min_voltage_cell));

            // +-----------------------------------------------+
            // | MAX max_cell_voltage                          |
            // | MAX max_voltage_cell (cell number)            |
            // +-----------------------------------------------+
            id(${yambms_id}_max_cell_voltage).publish_state(id(${yambms_id}_var_max_cell_voltage));
            id(${yambms_id}_max_voltage_cell).publish_state(id(${yambms_id}_var_max_voltage_cell));

            // +-----------------------------------------------+
            // | MIN cell_ovp                                  |
            // +-----------------------------------------------+
            id(${yambms_id}_cell_ovp).publish_state(id(${yambms_id}_var_min_cell_ovp));

            // +-----------------------------------------------+
            // | MAX cell_uvp                                  |
            // +-----------------------------------------------+
            id(${yambms_id}_cell_uvp).publish_state(id(${yambms_id}_var_max_cell_uvp));

            // +-----------------------------------------------+
            // | MIN temperature                               |
            // | MIN temperature_sensor                        |
            // +-----------------------------------------------+
            id(${yambms_id}_min_temperature).publish_state(id(${yambms_id}_var_min_temperature));
            id(${yambms_id}_min_temperature_sensor).publish_state(id(${yambms_id}_var_min_temperature_sensor));

            // +-----------------------------------------------+
            // | MAX temperature                               |
            // | MAX temperature_sensor                        |
            // +-----------------------------------------------+
            id(${yambms_id}_max_temperature).publish_state(id(${yambms_id}_var_max_temperature));
            id(${yambms_id}_max_temperature_sensor).publish_state(id(${yambms_id}_var_max_temperature_sensor));

            // +-----------------------------------------------+
            // | Equalizing state                              |
            // +-----------------------------------------------+
            if (id(${yambms_id}_var_equalizing_counter) > 0)
              id(${yambms_id}_equalizing).publish_state(true);
            else
              id(${yambms_id}_equalizing).publish_state(false);

            // +-----------------------------------------------+
            // | Charging allowed                              |
            // +-----------------------------------------------+
            if (id(${yambms_id}_switch_charging).state && id(${yambms_id}_var_charging_allowed_counter) > 0)
            {
              id(${yambms_id}_charging_allowed).publish_state(true);
            }
            else
              id(${yambms_id}_charging_allowed).publish_state(false);

            // +-----------------------------------------------+
            // | Discharging allowed                           |
            // +-----------------------------------------------+
            if (id(${yambms_id}_switch_discharging).state && id(${yambms_id}_var_discharging_allowed_counter) > 0)
            {
              id(${yambms_id}_discharging_allowed).publish_state(true);
            }
            else
              id(${yambms_id}_discharging_allowed).publish_state(false);

            // +-----------------------------------------------+
            // | BMS count                                     |
            // +-----------------------------------------------+
            // BMS count total
            id(${yambms_id}_bms_count).publish_state(id(${yambms_id}_var_bms_counter));
            // BMS count combined
            id(${yambms_id}_bms_combined).publish_state(id(${yambms_id}_var_to_combine_bms_counter));
            // BMS count blocking charge
            id(${yambms_id}_bms_blocking_charge).publish_state(id(${yambms_id}_var_bms_blocking_charge_counter));
            // BMS count blocking discharge
            id(${yambms_id}_bms_blocking_discharge).publish_state(id(${yambms_id}_var_bms_blocking_discharge_counter));

            // +-----------------------------------------------+
            // | Shunt count                                   |
            // +-----------------------------------------------+
            // Shunt count total
            id(${yambms_id}_shunt_count).publish_state(id(${yambms_id}_var_shunt_counter));
            // Shunt count combined
            id(${yambms_id}_shunt_combined).publish_state(id(${yambms_id}_var_to_combine_shunt_counter));

            // +-----------------------------------------------+
            // | Global vars reset                             |
            // +-----------------------------------------------+
            id(${yambms_id}_var_errors_bitmask) = 0;
            id(${yambms_id}_var_errors_bitmask_counter) = 0;
            id(${yambms_id}_var_bms_total_voltage) = 0.0;
            id(${yambms_id}_var_shunt_total_voltage) = 0.0;
            id(${yambms_id}_var_bms_total_current) = 0.0;
            id(${yambms_id}_var_shunt_total_current) = 0.0;
            id(${yambms_id}_var_bms_total_power) = 0.0;
            id(${yambms_id}_var_shunt_total_power) = 0.0;
            id(${yambms_id}_var_bms_total_soc) = 0.0;
            id(${yambms_id}_var_shunt_total_soc) = 0.0;
            id(${yambms_id}_var_bms_total_soh) = 0.0;
            id(${yambms_id}_var_total_battery_capacity) = 0.0;
            id(${yambms_id}_var_total_battery_capacity_remaining) = 0.0;
            id(${yambms_id}_var_total_max_charge_current) = 0.0;
            id(${yambms_id}_var_total_max_discharge_current) = 0.0;
            id(${yambms_id}_var_total_charging_cycles) = 0.0;
            id(${yambms_id}_var_max_balance_trigger_voltage) = 0.0;
            id(${yambms_id}_var_min_cell_voltage) = 5.0;
            id(${yambms_id}_var_min_voltage_cell) = 0;
            id(${yambms_id}_var_max_cell_voltage) = 0.0;
            id(${yambms_id}_var_max_voltage_cell) = 0;
            id(${yambms_id}_var_min_cell_ovp) = 5.0;
            id(${yambms_id}_var_max_cell_uvp) = 0.0;
            id(${yambms_id}_var_min_temperature) = 100.0;
            id(${yambms_id}_var_min_temperature_sensor) = 0;
            id(${yambms_id}_var_max_temperature) = -100.0;
            id(${yambms_id}_var_max_temperature_sensor) = 0;
            id(${yambms_id}_var_equalizing_counter) = 0;
            id(${yambms_id}_var_charging_allowed_counter) = 0;
            id(${yambms_id}_var_discharging_allowed_counter) = 0;
            id(${yambms_id}_var_bms_blocking_charge_counter) = 0;
            id(${yambms_id}_var_bms_blocking_discharge_counter) = 0;

            // The devices are once again authorized to communicate their informations
            id(${yambms_id}_var_to_combine_bms_number) = 1;
            id(${yambms_id}_var_to_combine_shunt_number) = 1;
          }

          // +-----------------------------------------------+
          // | STEP 3 - YamBMS Logic                         |
          // +-----------------------------------------------+
          if ((id(${yambms_id}_bms_combined).has_state()) &&
              (id(${yambms_id}_total_voltage).has_state()) &&
              (id(${yambms_id}_current).has_state()) &&
              (id(${yambms_id}_power).has_state()) &&
              (id(${yambms_id}_battery_soc).has_state()) &&
              (id(${yambms_id}_battery_soh).has_state()) &&
              (id(${yambms_id}_battery_capacity).has_state()) &&
              (id(${yambms_id}_equalizing).has_state()) &&
              (id(${yambms_id}_max_cell_voltage).has_state()) &&
              (id(${yambms_id}_max_charge_current).has_state()) &&
              (id(${yambms_id}_max_discharge_current).has_state()) &&
              (id(${yambms_id}_cell_ovp).has_state()) &&
              (id(${yambms_id}_cell_uvp).has_state()) &&
              (id(${yambms_id}_cell_count).has_state()) &&
              (id(${yambms_id}_charging_allowed).has_state()) &&
              (id(${yambms_id}_discharging_allowed).has_state()))
          {
            // +-----------------------------------------------+
            // | Charging Logic                                |
            // +-----------------------------------------------+
            // EOC => Float
            if ((id(${yambms_id}_var_charge_status) == "EOC") && (id(${yambms_id}_switch_float).state)) id(${yambms_id}_var_charge_status) = "Float";
            // No Float => EOC
            else if ((id(${yambms_id}_var_charge_status) == "Float") && (!id(${yambms_id}_switch_float).state)) id(${yambms_id}_var_charge_status) = "EOC";
            // No Force Bulk => Wait
            else if ((id(${yambms_id}_var_force_bulk) == true) && (!id(${yambms_id}_switch_force_bulk).state)) id(${yambms_id}_var_charge_status) = "Wait";
            // Force Float
            else if (id(${yambms_id}_var_force_float) == true) id(${yambms_id}_var_charge_status) = "Float";

            // +-----------------------------------------------+
            // | Charging allowed (BMS and YamBMS)             |
            // +-----------------------------------------------+
            else if ((id(${yambms_id}_charging_allowed).has_state()) && (id(${yambms_id}_charging_allowed).state))
            {
              // Variables
              float cell_bulk_v = (id(${yambms_id}_bulk_voltage).state / id(${yambms_id}_cell_count).state);
              float cell_rebulk_v = (id(${yambms_id}_rebulk_voltage).state / id(${yambms_id}_cell_count).state);
              float max_cell_v = id(${yambms_id}_max_cell_voltage).state;

              // +-----------------------------------------------+
              // | Force Bulk Logic                              |
              // +-----------------------------------------------+
              if (id(${yambms_id}_switch_force_bulk).state)
              {
                id(${yambms_id}_var_force_bulk) = true;
                // Stop Force Bulk when entering the Cut-Off phase
                if (id(${yambms_id}_var_charge_status) == "Cut-Off")
                  id(${yambms_id}_switch_force_bulk).turn_off();
                // Force Bulk
                else id(${yambms_id}_var_charge_status) = "Bulk";
              }

              // +-----------------------------------------------+
              // | Rebulk Logic                                  |
              // +-----------------------------------------------+
              // Max Cell V. <= 3.3V (default value)
              else if (max_cell_v <= cell_rebulk_v) id(${yambms_id}_var_charge_status) = "Bulk";
              // SoC <= 85% (default value)
              else if (id(${yambms_id}_battery_soc).state <= id(${yambms_id}_rebulk_soc).state) id(${yambms_id}_var_charge_status) = "Bulk";
              // Force Charge requested
              else if (id(${yambms_id}_requested_force_charge).state) id(${yambms_id}_var_charge_status) = "Bulk";

              // +-----------------------------------------------+
              // | Charging Logic (Bulk)                         |
              // +-----------------------------------------------+
              if ((id(${yambms_id}_var_charge_status) != "EOC") && (id(${yambms_id}_var_charge_status) != "Float"))
              {

                float cv_min = id(${yambms_id}_var_cell_min_charge_v);
                float cv_max = id(${yambms_id}_var_cell_max_charge_v);
                float current = id(${yambms_id}_current).state;
                float cutoff_resistance = ((cv_max - cv_min) / id(${yambms_id}_battery_capacity).state / 0.05);
                static int cutoff_counter = 0;
                static int bulk_counter = 0;

                // +-----------------------------------------------+
                // | Cut-Off Charging Logic                        |
                // +-----------------------------------------------+
                if (current >= 0)
                {
                  float cutoff_voltage = (max_cell_v - cutoff_resistance * current);

                  if(cutoff_voltage > cv_min)
                  {
                    cutoff_counter++;
                    bulk_counter = 0;
                  }
                  else
                  {
                    bulk_counter++;
                    cutoff_counter = 0;
                  }

                  // Entering the Cut-Off phase
                  // The criteria check must succeed 5 times in a row to ensure
                  // that these are not random/erroneous/false readings of the BMS
                  if (cutoff_counter > 4)
                  {
                    ESP_LOGI("yambms", "Entering the Cut-Off phase...");

                    // Cut-Off : the end of charging is near
                    id(${yambms_id}_var_charge_status) = "Cut-Off";

                    // If the EOC Timer switch is enabled
                    if (id(${yambms_id}_switch_eoc_timer).state)
                    {
                      // Start EOC timer
                      // The charging process ends at the latest at the end of this timer (30min by default)
                      if (!id(${yambms_id}_script_eoc_timer).is_running())
                        id(${yambms_id}_script_eoc_timer).execute();
                    }
                    // End Of Charge
                    // Equalizing
                    if (id(${yambms_id}_equalizing).state)
                    {
                      // Stop cut-off timer
                      if (id(${yambms_id}_script_cutoff_timer).is_running())
                        id(${yambms_id}_script_cutoff_timer).stop();
                    }
                    // Not Equalizing => Start cut-off timer
                    // If the conditions continue to be respected the charging process will stop in 60s (default value)
                    else if (!id(${yambms_id}_script_cutoff_timer).is_running())
                      id(${yambms_id}_script_cutoff_timer).execute();
                  }
                  // Continue charging
                  // The criteria check must succeed 5 times in a row to ensure
                  // that these are not random/erroneous/false readings of the BMS
                  else if (bulk_counter > 4)
                  {
                    // Stop timer
                    if (id(${yambms_id}_script_eoc_timer).is_running()) id(${yambms_id}_script_eoc_timer).stop();
                    if (id(${yambms_id}_script_cutoff_timer).is_running()) id(${yambms_id}_script_cutoff_timer).stop();
                    // Balancing : the BMS is equalizing the cells
                    if (id(${yambms_id}_equalizing).state) id(${yambms_id}_var_charge_status) = "Balancing";
                    // Bulk
                    else id(${yambms_id}_var_charge_status) = "Bulk";
                  }
                }
                // Discharging (!= "EOC" | != "Float")
                // Condition for not exiting the Cut-Off phase too quickly if the discharge current is minimal
                else if (max_cell_v < (cell_bulk_v - cutoff_resistance))
                {
                  // Reset cut-off counter
                  cutoff_counter = 0;
                  // Stop timer
                  if (id(${yambms_id}_script_eoc_timer).is_running()) id(${yambms_id}_script_eoc_timer).stop();
                  if (id(${yambms_id}_script_cutoff_timer).is_running()) id(${yambms_id}_script_cutoff_timer).stop();
                  // Bulk
                  id(${yambms_id}_var_charge_status) = "Bulk";
                }
              }
            }
            // Charging not allowed (BMS or YamBMS)
            else if ((id(${yambms_id}_var_charge_status) != "Init") && (id(${yambms_id}_var_bms_charging_logic) == false))
            {
              id(${yambms_id}_var_charge_status) = "Wait";
            }

            // Publish the sensor
            id(${yambms_id}_charging_status).publish_state(id(${yambms_id}_var_charge_status));

            // +-----------------------------------------------+
            // | Charging Instruction                          |
            // +-----------------------------------------------+
            std::string charging_instruction;
            // Bulk Charge
            if ((id(${yambms_id}_var_charge_status) != "Init") &&
                (id(${yambms_id}_var_charge_status) != "Wait") &&
                (id(${yambms_id}_var_charge_status) != "EOC") &&
                (id(${yambms_id}_var_charge_status) != "Float"))
            {
              id(${yambms_id}_var_eoc) = false; // SoC 100% can't be sent
              charging_instruction = "Bulk";
            }
            // Float Charge
            else if (id(${yambms_id}_var_charge_status) == "Float")
            {
              charging_instruction = "Float";
            }
            // Init / Wait / EOC
            else charging_instruction = "Stop";
            // Publish the sensor
            id(${yambms_id}_charging_instruction).publish_state(charging_instruction);

            // +-----------------------------------------------+
            // | Discharging Instruction                       |
            // +-----------------------------------------------+
            bool discharging_instruction = false;
            if (id(${yambms_id}_discharging_allowed).state)
              discharging_instruction = true;
            if (id(${yambms_id}_total_voltage).state <= id(${yambms_id}_requested_discharge_voltage).state)
              discharging_instruction = false;
            // Publish the sensor
            id(${yambms_id}_discharging_instruction).publish_state(discharging_instruction);

            // +-----------------------------------------------+
            // | Requested Charge Voltage (CVL)                |
            // +-----------------------------------------------+
            float requested_charge_voltage;
            if (id(${yambms_id}_bms_combined).state == 0) // no BMS combined
              requested_charge_voltage = 0;
            // Bulk
            else if (charging_instruction == "Bulk")
              requested_charge_voltage = (id(${yambms_id}_bulk_voltage).state + id(${yambms_id}_inverter_offset_v).state + id(${yambms_id}_var_auto_cvl));
            // Float
            else if (charging_instruction == "Float")
              requested_charge_voltage = (id(${yambms_id}_float_voltage).state + id(${yambms_id}_inverter_offset_v).state) + id(${yambms_id}_var_auto_float);
            // Stop Charging
            else requested_charge_voltage = (id(${yambms_id}_rebulk_voltage).state + id(${yambms_id}_inverter_offset_v).state);
            // Publish the sensor
            id(${yambms_id}_requested_charge_voltage).publish_state(requested_charge_voltage);

            // +-----------------------------------------------+
            // | Requested Discharge Voltage (DVL)             |
            // +-----------------------------------------------+
            float requested_discharge_voltage;
            if (id(${yambms_id}_bms_combined).state == 0) // no BMS combined
              requested_discharge_voltage = 0;
            else
              requested_discharge_voltage = ((id(${yambms_id}_cell_uvp).state + 0.2) * id(${yambms_id}_cell_count).state);
            // Publish the sensor
            id(${yambms_id}_requested_discharge_voltage).publish_state(requested_discharge_voltage);

            // +-----------------------------------------------+
            // | Requested Charge Current (CCL)                |
            // +-----------------------------------------------+
            int cc_step = id(${yambms_id}_var_charge_current_step);
            if (cc_step == id(${yambms_id}_var_auto_ccl_functions_count) + 1)
            {
              ESP_LOGD("yambms_debug", "Entering Requested CCL...");

              // Charging Not Allowed
              int requested_charge_current = 0;
              // Charging Allowed
              if ((charging_instruction == "Bulk") || (charging_instruction == "Float"))
              {
                float auto_limit = std::min({
                  id(${yambms_id}_var_auto_ccl), 
                  id(${yambms_id}_var_auto_eoc), 
                  id(${yambms_id}_var_auto_temperature_ccl)
                });

                requested_charge_current = round(id(${yambms_id}_max_charge_current).state + auto_limit);
                if (requested_charge_current < 0) requested_charge_current = 0;
              }
              // Publish the sensor
              id(${yambms_id}_requested_charge_current).publish_state(requested_charge_current);
              id(${yambms_id}_var_charge_current_step)++;
              id(${yambms_id}_var_requested_ccl_init) = true;
            }

            // +-----------------------------------------------+
            // | Requested Discharge Current (DCL)             |
            // +-----------------------------------------------+
            int dc_step = id(${yambms_id}_var_discharge_current_step);
            if (dc_step == id(${yambms_id}_var_auto_dcl_functions_count) + 1)
            {
              ESP_LOGD("yambms_debug", "Entering Requested DCL...");
              // Discharging Not Allowed
              int requested_discharge_current = 0;
              // Discharging Allowed
              if (discharging_instruction == true)
              {
                float auto_limit = std::min({
                  id(${yambms_id}_var_auto_dcl), 
                  id(${yambms_id}_var_auto_temperature_dcl)
                });

                requested_discharge_current = round(id(${yambms_id}_max_discharge_current).state + auto_limit);
                if (requested_discharge_current < 0) requested_discharge_current = 0;
              }
              // Publish the sensor
              id(${yambms_id}_requested_discharge_current).publish_state(requested_discharge_current);
              id(${yambms_id}_var_discharge_current_step)++;
              id(${yambms_id}_var_requested_dcl_init) = true;
            }

            // +-----------------------------------------------+
            // | End Of STEP 3 : YamBMS initialized ?          |
            // | The datas can be communicated to the inverter |
            // +-----------------------------------------------+
            if ((id(${yambms_id}_bms_combined).state > 0) &&
                (id(${yambms_id}_var_charge_status) != "Init") &&
                (id(${yambms_id}_total_voltage).state > 0) &&
                (id(${yambms_id}_min_temperature).state < 100) &&
                (id(${yambms_id}_max_temperature).state > -100) &&
                (id(${yambms_id}_requested_charge_voltage).state > 0) &&
                (id(${yambms_id}_requested_discharge_voltage).state > 0) &&
                (id(${yambms_id}_var_requested_ccl_init) == true) &&
                (id(${yambms_id}_var_requested_dcl_init) == true))
            {
              id(${yambms_id}_var_initialized) = true;
            }
            else id(${yambms_id}_var_initialized) = false;
          }

          // +-----------------------------------------------+
          // | DEBUG LOGS                                    |
          // +-----------------------------------------------+
          if (id(${yambms_id}_var_initialized) == true) ESP_LOGD("yambms_debug", "===> YamBMS initialized <=== : true");
          else ESP_LOGD("yambms_debug", "===> YamBMS initialized <=== : false");
          if (id(${yambms_id}_total_voltage).has_state()) ESP_LOGD("yambms_debug", "Battery Voltage : %f V", id(${yambms_id}_total_voltage).state);
          if (id(${yambms_id}_current).has_state()) ESP_LOGD("yambms_debug", "Battery Current : %f A", id(${yambms_id}_current).state);
          if (id(${yambms_id}_power).has_state()) ESP_LOGD("yambms_debug", "Battery Power : %f W", id(${yambms_id}_power).state);
          if (id(${yambms_id}_battery_soc).has_state()) ESP_LOGD("yambms_debug", "Battery SOC : %f %%", id(${yambms_id}_battery_soc).state);
          if (id(${yambms_id}_battery_soh).has_state()) ESP_LOGD("yambms_debug", "Battery SOH : %f %%", id(${yambms_id}_battery_soh).state);
          if (id(${yambms_id}_min_temperature).has_state()) ESP_LOGD("yambms_debug", "Min temp. : %f °C", id(${yambms_id}_min_temperature).state);
          if (id(${yambms_id}_max_temperature).has_state()) ESP_LOGD("yambms_debug", "Max temp. : %f °C", id(${yambms_id}_max_temperature).state);
          ESP_LOGD("yambms_debug", "Charge Status : %s", id(${yambms_id}_var_charge_status).c_str());
          if (id(${yambms_id}_charging_instruction).has_state()) ESP_LOGD("yambms_debug", "Charging instruction : %s", id(${yambms_id}_charging_instruction).state.c_str());
          if (id(${yambms_id}_discharging_instruction).has_state())
          {
            bool discharging_instruction = id(${yambms_id}_discharging_instruction).state;
            if (discharging_instruction == true) ESP_LOGD("yambms_debug", "Discharging instruction  : true");
            else ESP_LOGD("yambms_debug", "Discharging instruction  : false");
          }
          if (id(${yambms_id}_requested_charge_voltage).has_state()) ESP_LOGD("yambms_debug", "Requested CVL : %f V", id(${yambms_id}_requested_charge_voltage).state);
          if (id(${yambms_id}_requested_charge_voltage).has_state()) ESP_LOGD("yambms_debug", "Requested DVL : %f V", id(${yambms_id}_requested_discharge_voltage).state);
          if (id(${yambms_id}_var_requested_ccl_init) == true) ESP_LOGD("yambms_debug", "Requested CCL : %f A", id(${yambms_id}_requested_charge_current).state);
          if (id(${yambms_id}_var_requested_dcl_init) == true) ESP_LOGD("yambms_debug", "Requested DCL : %f A", id(${yambms_id}_requested_discharge_current).state);

          // if (id().has_state()) ESP_LOGD("yambms_debug", "Text : %f V", id().state);



# +--------------------------------------+
# | scripts                              |
# +--------------------------------------+
script:
  - id: ${yambms_id}_script_eoc_timer
    then:
      - delay: ${yambms_eoc_timer}min
      - script.execute: ${yambms_id}_script_eoc
  - id: ${yambms_id}_script_cutoff_timer
    then:
      - delay: ${yambms_cutoff_timer}s
      - script.execute: ${yambms_id}_script_eoc
  - id: ${yambms_id}_script_eoc
    then:
      - lambda: |-
          // Stop timer
          if (id(${yambms_id}_script_eoc_timer).is_running()) id(${yambms_id}_script_eoc_timer).stop();
          if (id(${yambms_id}_script_cutoff_timer).is_running()) id(${yambms_id}_script_cutoff_timer).stop();
          // EOC script
          if (id(${yambms_id}_switch_float).state) id(${yambms_id}_var_charge_status) = "Float";
          else id(${yambms_id}_var_charge_status) = "EOC";
          id(${yambms_id}_var_eoc) = true;                                         // SOC 100% can be sent
          id(${yambms_id}_var_eoc_timestamp) = id(my_time).utcnow().timestamp;     // Store charge completion timestamp



# +--------------------------------------+
# | switch                               |
# +--------------------------------------+
switch:
  - platform: template
    name: "${name} ${yambms_name} Charge enabled"
    id: ${yambms_id}_switch_charging
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Discharge enabled"
    id: ${yambms_id}_switch_discharging
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Float charge enabled"
    id: ${yambms_id}_switch_float
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} EOC Timer enabled"
    id: ${yambms_id}_switch_eoc_timer
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Force Bulk (top bal)"
    id: ${yambms_id}_switch_force_bulk
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Request force charge"
    id: ${yambms_id}_switch_request_force_charge
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config



# +--------------------------------------+
# | binary_sensor                        |
# +--------------------------------------+
binary_sensor:
  # equalizing
  - platform: template
    id: ${yambms_id}_equalizing
    name: "${name} ${yambms_name} BMS equalizing state"
  # charging_allowed
  - platform: template
    id: ${yambms_id}_charging_allowed
    name: "${name} ${yambms_name} BMS charging allowed"
  # discharging_allowed
  - platform: template
    id: ${yambms_id}_discharging_allowed
    name: "${name} ${yambms_name} BMS discharging allowed"
  # +--------------------------------------+
  # | Discharging Instruction              |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${yambms_name} Discharging Instruction"
    id: ${yambms_id}_discharging_instruction
    icon: mdi:battery-minus
  # +--------------------------------------+
  # | Requested Force Charge               |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${yambms_name} Requested Force Charge"
    id: ${yambms_id}_requested_force_charge
    icon: mdi:battery-charging-low
    lambda: |-
      if (id(${yambms_id}_switch_request_force_charge).state)
      {
        int soc = id(${yambms_id}_battery_soc).state;
        if (soc <= id(${yambms_id}_request_force_charge_start_soc).state) return true;
        else if (soc >= id(${yambms_id}_request_force_charge_stop_soc).state) return false;
        else if (id(${yambms_id}_requested_force_charge).state) return true;
        else return false;
      }
      else return false;



# +--------------------------------------+
# | number                               |
# +--------------------------------------+
number:
  #
  # Min/max values ​​are updated automatically based on battery chemistry and cell count.
  #
  - platform: template
    name: "${name} ${yambms_name} Bulk voltage"
    id: "${yambms_id}_bulk_voltage"
    step: 0.1
    min_value: 54.0 # LFP 3.37 * 16 cells
    max_value: 58.4 # LFP 3.65 * 16 cells
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: "${yambms_bulk_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Float voltage"
    id: "${yambms_id}_float_voltage"
    step: 0.1
    min_value: 52.8 # LFP 3.30 * 16 cells
    max_value: 55.2 # LFP 3.45 * 16 cells
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: "${yambms_float_v}"
    unit_of_measurement: V
    icon: mdi:battery-charging
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Rebulk V."
    id: "${yambms_id}_rebulk_voltage"
    step: 0.1
    min_value: 51.2 # LFP 3.20 * 16 cells
    max_value: 54.0 # LFP 3.37 * 16 cells
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: "${yambms_rebulk_v}"
    unit_of_measurement: V
    icon: mdi:sine-wave
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Rebulk SoC"
    id: "${yambms_id}_rebulk_soc"
    step: 1
    min_value: 0
    max_value: 100
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 85
    unit_of_measurement: '%'
    icon: mdi:battery-medium
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Inverter Offset V."
    id: "${yambms_id}_inverter_offset_v"
    step: 0.1
    min_value: 0
    max_value: 1
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 0.0
    unit_of_measurement: V
    icon: mdi:sine-wave
    optimistic: true
    entity_category: config
    # internal: true
  - platform: template
    name: "${name} ${yambms_name} Max requested charge current"
    id: "${yambms_id}_max_requested_charge_current"
    step: 5
    min_value: 0
    max_value: ${yambms_max_requested_charge_current}
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: ${yambms_max_requested_charge_current}
    unit_of_measurement: A
    icon: mdi:current-dc
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Max requested discharge current"
    id: "${yambms_id}_max_requested_discharge_current"
    step: 5
    min_value: 0
    max_value: ${yambms_max_requested_discharge_current}
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: ${yambms_max_requested_discharge_current}
    unit_of_measurement: A
    icon: mdi:current-dc
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Request Force Charge Start SoC"
    id: "${yambms_id}_request_force_charge_start_soc"
    step: 1
    min_value: 0
    max_value: 100
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 10
    unit_of_measurement: '%'
    icon: mdi:battery-low
    optimistic: true
    entity_category: config
  - platform: template
    name: "${name} ${yambms_name} Request Force Charge Stop SoC"
    id: "${yambms_id}_request_force_charge_stop_soc"
    step: 1
    min_value: 0
    max_value: 100
    restore_value: true
    mode: "${yambms_input_number_mode}"
    initial_value: 30
    unit_of_measurement: '%'
    icon: mdi:battery-medium
    optimistic: true
    entity_category: config



# +--------------------------------------+
# | sensor                               |
# +--------------------------------------+
sensor:
  # max_charge_current SUM
  - platform: template
    id: ${yambms_id}_max_charge_current
    name: "${name} ${yambms_name} Max Charge current"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # max_discharge_current SUM
  - platform: template
    id: ${yambms_id}_max_discharge_current
    name: "${name} ${yambms_name} Max Discharge Current"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # cell_count
  - platform: template
    name: "${name} ${yambms_name} Cell Count"
    id: ${yambms_id}_cell_count
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    lambda: return ${yambms_cell_count};

  # min_voltage_cell MIN
  - platform: template
    id: ${yambms_id}_min_voltage_cell
    name: "${name} ${yambms_name} Min Voltage Cell"
    update_interval: ${yambms_update_interval}
    icon: mdi:numeric
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # max_voltage_cell MAX
  - platform: template
    id: ${yambms_id}_max_voltage_cell
    name: "${name} ${yambms_name} Max Voltage Cell"
    update_interval: ${yambms_update_interval}
    icon: mdi:numeric
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # min_cell_voltage MIN
  - platform: template
    id: ${yambms_id}_min_cell_voltage
    name: "${name} ${yambms_name} Min Cell Voltage"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - or:
        - throttle: 10s
        - delta: 0.001

  # max_cell_voltage MAX
  - platform: template
    id: ${yambms_id}_max_cell_voltage
    name: "${name} ${yambms_name} Max Cell Voltage"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - or:
        - throttle: 10s
        - delta: 0.001

  # delta_cell_voltage
  - platform: template
    id: ${yambms_id}_delta_cell_voltage
    name: "${name} ${yambms_name} Delta Cell Voltage"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - or:
        - throttle: 10s
        - delta: 0.001
    lambda: return (id(${yambms_id}_max_cell_voltage).state - id(${yambms_id}_min_cell_voltage).state);

  # total_voltage MEAN
  - platform: template
    id: ${yambms_id}_total_voltage
    name: "${name} ${yambms_name} Total Voltage"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    filters:
      - or:
        - throttle: 10s
        - delta: 0.01

  # current SUM
  - platform: template
    id: ${yambms_id}_current
    name: "${name} ${yambms_name} Current"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - or:
        - throttle: 10s
        - delta: 0.1

  # power SUM
  - platform: template
    id: ${yambms_id}_power
    name: "${name} ${yambms_name} Power"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # battery_soc MEAN
  - platform: template
    name: ${name} ${yambms_name} Battery SoC
    id: ${yambms_id}_battery_soc
    update_interval: ${yambms_update_interval}
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # battery_soh MEAN
  - platform: template
    id: ${yambms_id}_battery_soh
    name: ${name} ${yambms_name} Battery SoH
    update_interval: ${yambms_update_interval}
    unit_of_measurement: "%"
    state_class: measurement
    icon: mdi:battery-heart-variant
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # installed_battery_capacity SUM
  - platform: template
    id: ${yambms_id}_installed_battery_capacity
    name: "${name} ${yambms_name} Installed Battery Capacity"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: Ah
    state_class: measurement
    icon: mdi:car-battery
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    lambda: return id(${yambms_id}_var_total_installed_battery_capacity);

  # battery_capacity SUM
  - platform: template
    id: ${yambms_id}_battery_capacity
    name: "${name} ${yambms_name} Battery Capacity"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: Ah
    state_class: measurement
    icon: mdi:car-battery
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # battery_capacity_remaining SUM
  - platform: template
    id: ${yambms_id}_battery_capacity_remaining
    name: "${name} ${yambms_name} Capacity Remaining"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: Ah
    state_class: measurement
    icon: mdi:car-battery
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # cell_ovp MIN (Auto CCL)
  - platform: template
    id: ${yambms_id}_cell_ovp
    name: "${name} ${yambms_name} Cell OVP (MIN)"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - or:
        - throttle: 10s
        - delta: 0.001

  # cell_uvp MAX (Auto DCL and MAX Discharge Voltage)
  - platform: template
    id: ${yambms_id}_cell_uvp
    name: "${name} ${yambms_name} Cell UVP (MAX)"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - or:
        - throttle: 10s
        - delta: 0.001

  # balance_trigger_voltage MAX (Auto CVL)
  - platform: template
    id: ${yambms_id}_balance_trigger_voltage
    name: "${name} ${yambms_name} Balance Trigger Voltage (MAX)"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 3
    filters:
      - or:
        - throttle: 10s
        - delta: 0.001

  # MIN temperature
  - platform: template
    id: ${yambms_id}_min_temperature
    name: "${name} ${yambms_name} Min temperature"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: °C
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - delta: 0.2
      # - throttle_average: 10s

  # MAX temperature
  - platform: template
    id: ${yambms_id}_max_temperature
    name: "${name} ${yambms_name} Max temperature"
    update_interval: ${yambms_update_interval}
    unit_of_measurement: °C
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - delta: 0.2
      # - throttle_average: 10s

  # MIN temperature sensor
  - platform: template
    id: ${yambms_id}_min_temperature_sensor
    name: "${name} ${yambms_name} Min temperature sensor"
    update_interval: ${yambms_update_interval}
    icon: mdi:numeric
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # MAX temperature sensor
  - platform: template
    id: ${yambms_id}_max_temperature_sensor
    name: "${name} ${yambms_name} Max temperature sensor"
    update_interval: ${yambms_update_interval}
    icon: mdi:numeric
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # charging_cycles MEAN
  - platform: template
    id: ${yambms_id}_charging_cycles
    name: "${name} ${yambms_name} Charging Cycles"
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # Alarm - errors_bitmask bitwise AND (16bit)
  - platform: template
    id: ${yambms_id}_errors_bitmask_alarm
    name: "${name} ${yambms_name} Errors Bitmask Alarm"
    update_interval: ${yambms_update_interval}
    icon: mdi:alert-circle-outline
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # Warning - errors_bitmask bitwise OR (16bit)
  - platform: template
    id: ${yambms_id}_errors_bitmask_warning
    name: "${name} ${yambms_name} Errors Bitmask Warning"
    update_interval: ${yambms_update_interval}
    icon: mdi:alert-circle-outline
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # BMS in alarm (errors_bitmask_counter)
  - platform: template
    id: ${yambms_id}_errors_bitmask_counter
    name: "${name} ${yambms_name} BMS in alarm"
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # BMS count
  - platform: template
    name: ${name} ${yambms_name} BMS count
    id: ${yambms_id}_bms_count
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # BMS combined
  - platform: template
    name: ${name} ${yambms_name} BMS combined
    id: ${yambms_id}_bms_combined
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # BMS blocking charge
  - platform: template
    name: ${name} ${yambms_name} BMS blocking charge
    id: ${yambms_id}_bms_blocking_charge
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # BMS blocking discharge
  - platform: template
    name: ${name} ${yambms_name} BMS blocking discharge
    id: ${yambms_id}_bms_blocking_discharge
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # Shunt count
  - platform: template
    name: ${name} ${yambms_name} Shunt count
    id: ${yambms_id}_shunt_count
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # Shunt combined
  - platform: template
    name: ${name} ${yambms_name} Shunt combined
    id: ${yambms_id}_shunt_combined
    update_interval: ${yambms_update_interval}
    icon: mdi:counter
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1

  # Battery Charging Power
  - platform: template
    name: ${name} ${yambms_name} Battery Charging Power
    id: ${yambms_id}_battery_charging_power
    update_interval: ${yambms_update_interval}
    unit_of_measurement: 'W'
    device_class: power
    state_class: measurement
    accuracy_decimals: 0

  # Battery Discharging Power
  - platform: template
    name: ${name} ${yambms_name} Battery Discharging Power
    id: ${yambms_id}_battery_discharging_power
    update_interval: ${yambms_update_interval}
    unit_of_measurement: 'W'
    device_class: power
    state_class: measurement
    accuracy_decimals: 0

  # Daily Charging Energy
  - platform: total_daily_energy
    name: "${name} ${yambms_name} Daily Charging Energy"
    power_id: ${yambms_id}_battery_charging_power
    unit_of_measurement: 'kWh'
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  # Daily Discharging Energy
  - platform: total_daily_energy
    name: "${name} ${yambms_name} Daily Discharging Energy"
    power_id: ${yambms_id}_battery_discharging_power
    unit_of_measurement: 'kWh'
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 3
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  # +--------------------------------------+
  # |  Requested Charge Voltage  (CVL)     |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${yambms_name} Requested Charge Voltage
    id: ${yambms_id}_requested_charge_voltage
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - or:
        - throttle: 10s
        - delta: 0.1

  # +--------------------------------------+
  # |  Requested Discharge Voltage  (DVL)  |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${yambms_name} Requested Discharge Voltage
    id: ${yambms_id}_requested_discharge_voltage
    update_interval: ${yambms_update_interval}
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 1
    filters:
      - or:
        - throttle: 10s
        - delta: 0.1

  # +--------------------------------------+
  # |  Requested Charge Current  (CCL)     |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${yambms_name} Requested Charge Current
    id: ${yambms_id}_requested_charge_current
    update_interval: ${yambms_update_interval}
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    on_value:
      then:
        - component.update: ${yambms_id}_ccl_derating_reason

  # +--------------------------------------+
  # |  Requested Discharge Current  (DCL)  |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${yambms_name} Requested Discharge Current
    id: ${yambms_id}_requested_discharge_current
    update_interval: ${yambms_update_interval}
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    on_value:
      then:
        - component.update: ${yambms_id}_dcl_derating_reason

  # +--------------------------------------+
  # | Last Complete Charge                 |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${yambms_name} Last Complete Charge Timestamp"
    id: ${yambms_id}_eoc_timestamp_template
    device_class: timestamp
    entity_category: diagnostic
    internal: true
    lambda: return id(${yambms_id}_var_eoc_timestamp);
    on_value:
      then:
        - text_sensor.template.publish:
            id: ${yambms_id}_eoc_timestamp_human
            state: !lambda |-
                   char str[19];
                   strftime(str, sizeof(str), " %H:%M %d %b %Y", localtime(&id(${yambms_id}_var_eoc_timestamp)));
                   return  {str};



text_sensor:
  # +--------------------------------------+
  # | Charging Instruction                 |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${yambms_name} Charging Instruction"
    id: ${yambms_id}_charging_instruction
    update_interval: ${yambms_update_interval}
    icon: mdi:battery-plus
  # +--------------------------------------+
  # | Last Complete Charge                 |
  # +--------------------------------------+
  - platform: template
    name: ${name} ${yambms_name} Last Complete Charge
    id: ${yambms_id}_eoc_timestamp_human
    icon: mdi:clock-start
    entity_category: diagnostic
  # +--------------------------------------+
  # | ****** Cut-off Charging Logic ****** |
  # | ********* Charging  Status ********* |
  # +--------------------------------------+
  - platform: template
    name: "${name} ${yambms_name} Charging Status"
    id: ${yambms_id}_charging_status
    update_interval: ${yambms_update_interval}
    icon: mdi:battery-arrow-up

  # +--------------------------------------+
  # | YamBMS Errors Bitmask (16bit)        |
  # +--------------------------------------+

  # Bit 0     General alarm                                0000 0000 0000 0001         0x0001
  # Bit 1     Battery high voltage alarm                   0000 0000 0000 0010         0x0002
  # Bit 2     Battery low voltage alarm                    0000 0000 0000 0100         0x0004
  # Bit 3     Battery high temperature alarm               0000 0000 0000 1000         0x0008
  # Bit 4     Battery low temperature alarm                0000 0000 0001 0000         0x0010
  # Bit 5     Battery high temperature charge alarm        0000 0000 0010 0000         0x0020
  # Bit 6     Battery low temperature charge alarm         0000 0000 0100 0000         0x0040
  # Bit 7     Battery high discharge current alarm         0000 0000 1000 0000         0x0080
  # Bit 8     Battery high charge current alarm            0000 0001 0000 0000         0x0100
  # Bit 9     Contactor alarm                              0000 0010 0000 0000         0x0200
  # Bit 10    Short circuit alarm                          0000 0100 0000 0000         0x0400
  # Bit 11    BMS internal alarm                           0000 1000 0000 0000         0x0800
  # Bit 12    Cell imbalance alarm                         0001 0000 0000 0000         0x1000
  # Bit 13    Reserved                                     0010 0000 0000 0000         0x2000
  # Bit 14    Reserved                                     0100 0000 0000 0000         0x4000
  # Bit 15    Reserved                                     1000 0000 0000 0000         0x8000

  # YamBMS Protection Alarm (all-bms)
  - platform: template
    name: "${name} ${yambms_name} Alarm"
    id: ${yambms_id}_alarm
    update_interval: ${yambms_update_interval}
    entity_category: diagnostic
    icon: mdi:battery-alert
    lambda: |-
      // Error Bitmask ?
      uint16_t errors_bitmask = id(${yambms_id}_errors_bitmask_alarm).state;
      int eb_counter = id(${yambms_id}_errors_bitmask_counter).state;

      // At least one BMS in alarm
      if ((eb_counter > 0) & (eb_counter < id(${yambms_id}_var_bms_counter))) return {"Warning"};
      // All BMS are in alarm
      else if (errors_bitmask > 0)
      {
        if ((errors_bitmask & 0x0002)) return {"OVP"};         // Over Voltage Protection
        else if ((errors_bitmask & 0x0004)) return {"UVP"};    // Under Voltage Protection
        else if ((errors_bitmask & 0x0008)) return {"OTP"};    // Over Temp Protection
        else if ((errors_bitmask & 0x0020)) return {"COTP"};   // Charge Over Temp Protection
        else if ((errors_bitmask & 0x0010)) return {"UTP"};    // Under Temp Protection
        else if ((errors_bitmask & 0x0040)) return {"CUTP"};   // Charge Under Temp Protection
        else if ((errors_bitmask & 0x0080)) return {"DOCP"};   // Discharge Over Current Protection
        else if ((errors_bitmask & 0x0100)) return {"COCP"};   // Charge Over Current Protection
        else if ((errors_bitmask & 0x0400)) return {"SCP"};    // Short Circuit Protection
        else if ((errors_bitmask & 0x0800)) return {"BMS"};    // BMS Internal Alarm
        else if ((errors_bitmask & 0x1000)) return {"UBC"};    // Unbalanced Cell
        else return {"Alarm"};
      }
      // No Alarm
      else return {"NoAlarm"};

  # YamBMS Warning (one-bms)
  - platform: template
    name: "${name} ${yambms_name} Warning"
    id: ${yambms_id}_warning
    update_interval: ${yambms_update_interval}
    entity_category: diagnostic
    icon: mdi:battery-alert
    lambda: |-
      // Error Bitmask ?
      uint16_t errors_bitmask = id(${yambms_id}_errors_bitmask_warning).state;

      if (errors_bitmask > 0)
      {
        if ((errors_bitmask & 0x0002)) return {"OVP"};         // Over Voltage Protection
        else if ((errors_bitmask & 0x0004)) return {"UVP"};    // Under Voltage Protection
        else if ((errors_bitmask & 0x0008)) return {"OTP"};    // Over Temp Protection
        else if ((errors_bitmask & 0x0020)) return {"COTP"};   // Charge Over Temp Protection
        else if ((errors_bitmask & 0x0010)) return {"UTP"};    // Under Temp Protection
        else if ((errors_bitmask & 0x0040)) return {"CUTP"};   // Charge Under Temp Protection
        else if ((errors_bitmask & 0x0080)) return {"DOCP"};   // Discharge Over Current Protection
        else if ((errors_bitmask & 0x0100)) return {"COCP"};   // Charge Over Current Protection
        else if ((errors_bitmask & 0x0400)) return {"SCP"};    // Short Circuit Protection
        else if ((errors_bitmask & 0x0800)) return {"BMS"};    // BMS Internal Alarm
        else if ((errors_bitmask & 0x1000)) return {"UBC"};    // Unbalanced Cell
        else return {"Alarm"};
      }
      // No Alarm
      else return {"NoAlarm"};

  # +----------------------------------------+
  # | Charge Current Derating Reason         |
  # +----------------------------------------+
  - platform: template
    name: ${name} ${yambms_name} CCL Derating Reason
    id: ${yambms_id}_ccl_derating_reason
    icon: "mdi:information-outline"
    update_interval: never
    entity_category: diagnostic
    lambda: |-
      if (!id(${yambms_id}_requested_charge_current).has_state() ||
           id(${yambms_id}_requested_charge_current).state == 0)
      {
        return {"Charge Disabled"};
      }

      float t_limit = id(${yambms_id}_var_auto_temperature_ccl);
      float e_limit = id(${yambms_id}_var_auto_eoc);
      float c_limit = id(${yambms_id}_var_auto_ccl);

      float min_val = std::min({t_limit, e_limit, c_limit});

      if (min_val == 0.0f) return {"No Derating"};
      if (min_val == t_limit) return {"Temperature Derating"};
      if (min_val == e_limit) return {"EOC Derating"};
      if (min_val == c_limit) return {"AutoCCL Derating"};
      
      return {"Unknown"};

  # +----------------------------------------+
  # | Discharge Current Derating Reason      |
  # +----------------------------------------+
  - platform: template
    name: ${name} ${yambms_name} DCL Derating Reason
    id: ${yambms_id}_dcl_derating_reason
    icon: "mdi:information-outline"
    update_interval: never
    entity_category: diagnostic
    lambda: |-
      if (!id(${yambms_id}_requested_discharge_current).has_state() ||
           id(${yambms_id}_requested_discharge_current).state == 0)
      {
        return {"Discharge Disabled"};
      }

      float t_limit = id(${yambms_id}_var_auto_temperature_dcl);
      float d_limit = id(${yambms_id}_var_auto_dcl);

      float min_val = std::min(t_limit, d_limit);

      if (min_val == 0.0f) return {"No Derating"};
      if (min_val == t_limit) return {"Temperature Derating"};
      if (min_val == d_limit) return {"AutoDCL Derating"};
      
      return {"Unknown"};
