# Updated : 2026.02.07
# Version : 1.2.9
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

esphome:
  on_boot:
    - priority: -100.0
      then:
        - lambda: |-
            id(${yambms_id}_var_auto_ccl_functions_count)++;

substitutions:
  # +--------------------------------------+
  # | Use the settings below with caution  |
  # +--------------------------------------+
  # Auto charge current control will automatically reduce the charging current as a cell reaches the BMS "cell_voltage_overvoltage_protection" value.
  # Tapering will begin once the maximum cell voltage exceeds float voltage.
  # If unsure, leave the below settings as default, this will ensure charge current will taper correctly.
  # Factor to control the end of the charge current curve. A setting below 2 will extend the curve, above 2 will shorten the curve.
  charge_a_factor_curve_end: '2.0'
  # Factor to adjust the shape of the charge current curve.
  # A setting above 1 will reduce current at a slow rate after the float voltage is reached, then increase as a cell approaches the BMS "cell_voltage_overvoltage_protection" value.
  # A factor below 1 will reduce current at a fast rate after the float voltage is reached, then slow as a cell approaches the BMS "cell_voltage_overvoltage_protection" value.
  charge_a_factor_curve_shape: '1.8'

switch:
  - platform: template
    name: ${name} ${yambms_name} Automatic Charge Current
    id: ${yambms_id}_switch_auto_ccl
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config

interval:
  - interval: ${yambms_update_interval}
    then:
      # +------------------------------------------+
      # | Auto Charge Current Limit                |
      # +------------------------------------------+
      - lambda: |-
          int cc_step = id(${yambms_id}_var_charge_current_step);
          if (cc_step >= 1 && cc_step < id(${yambms_id}_var_auto_ccl_functions_count) + 1)
          {
            ESP_LOGD("yambms_debug", "Entering Auto CCL...");

            // Use static variables to persist state between interval runs
            static float current_output = 0.0f;
            static bool is_initialized = false;

            // Configuration
            float max_current           = id(${yambms_id}_max_charge_current).state;
            auto& output_id             = id(${yambms_id}_var_auto_ccl);
            float alpha                 = 0.15f;
            float min_amp_increase_step = 1.0; 

            // Define raw inputs
            float max_cell_v = id(${yambms_id}_max_cell_voltage).state;
            float cell_count = id(${yambms_id}_cell_count).state;

            float cell_bulk_v = (id(${yambms_id}_bulk_voltage).state / cell_count);
            float cell_float_v = (id(${yambms_id}_float_voltage).state / cell_count);
            float cell_high_v = ((id(${yambms_id}_cell_ovp).state + cell_bulk_v) / 2);

            // Exit if critical data is missing
            if (isnan(max_current) || isnan(max_cell_v) || isnan(cell_count)) {
              output_id = 0.0f;
              id(${yambms_id}_var_charge_current_step)++;
              return;
            }
          
            // Check switch enabled
            if (!id(${yambms_id}_switch_auto_ccl).state) {
              output_id = 0.0f;
              id(${yambms_id}_var_charge_current_step)++;
              return;
            }

            // Calculate initial current delta
            double delta = 0.0;

            if (max_cell_v > cell_high_v) {
              delta = -max_current;
            } else {
              double ratio = max(0.0, ((max_cell_v - cell_float_v) / (cell_high_v - cell_float_v)));
              double curve = pow(${charge_a_factor_curve_end}, pow(ratio, ${charge_a_factor_curve_shape}));
              delta = max(0.0, (-curve + 2) * max_current) - max_current;
            }

            if (!is_initialized) {
              current_output = delta;
              is_initialized = true;
            }

            // Apply decrease in current instantly      
            // This means that cell voltage increases will be reacted to quickly
            if (delta < current_output) {
               current_output = delta;
            } 
            // Apply increase in current slowly, prevent oscillation of cell voltage
            else {
               // Calculate the gap to output
               float gap = delta - current_output;
               
               // Calculate exponential moving average
               float step = gap * alpha;
               
               // Apply minimum increase step
               // If the calculated step is tiny, force it to be at least min_amp_increase_step
               if (step < min_amp_increase_step) {
                   step = min_amp_increase_step;
               }
               
               // Calculate output
               if (step > gap) {
                   current_output = delta;
               } else {
                   current_output += step;
               }
            }

            // Update global
            current_output = round(current_output * 10) / 10.0;
            output_id = current_output;
            id(${yambms_id}_var_charge_current_step)++;
          }