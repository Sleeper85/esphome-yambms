# Updated : 2026.02.07
# Version : 1.2.9
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

esphome:
  on_boot:
    - priority: -100.0
      then:
        - lambda: |-
            id(${yambms_id}_var_auto_dcl_functions_count)++;

substitutions:
  # +--------------------------------------+
  # | Use the settings below with caution  |
  # +--------------------------------------+
  # Auto discharge current control will automatically reduce the charging current as a cell approaches the BMS "cell_voltage_undervoltage_protection" value.
  # If unsure, leave the below settings as default, this will ensure discharge current will taper correctly.
  # Factor to control the end of the discharge current curve. A setting below 2 will extend the curve, above 2 will shorten the curve.
  discharge_a_factor_curve_end: '2.0'
  # Factor to adjust the shape of the charge current curve.
  # A setting above 1 will reduce current at a slow rate after the float voltage is reached, then increase as a cell approaches the BMS "cell_voltage_undervoltage_protection" value.
  # A factor below 1 will reduce current at a fast rate after the float voltage is reached, then slow as a cell approaches the BMS "cell_voltage_undervoltage_protection" value.
  discharge_a_factor_curve_shape: '1.8'
  # Discharge knee voltage, the point at which a cell will reduce in voltage more rapidly. For LiFePO4 cells, this is generally considered to be 3.1v.
  discharge_knee_v: '3.1'

switch:
  - platform: template
    name: ${name} ${yambms_name} Automatic Discharge Current
    id: ${yambms_id}_switch_auto_dcl
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config

interval:
  - interval: ${yambms_update_interval}
    then:
      # +------------------------------------------+
      # | Auto Discharge Current Limit             |
      # +------------------------------------------+
      - lambda: |-
          int dc_step = id(${yambms_id}_var_discharge_current_step);
          if (dc_step >= 1 && dc_step < id(${yambms_id}_var_auto_dcl_functions_count) + 1)
          {
            ESP_LOGD("yambms_debug", "Entering Auto DCL...");

            // Use static variables to persist state between interval runs
            static float current_output = 0.0f;
            static bool is_initialized = false;

            // Configuration
            float max_current           = id(${yambms_id}_max_discharge_current).state;
            auto& output_id             = id(${yambms_id}_var_auto_dcl);
            float alpha                 = 0.15f;
            float min_amp_increase_step = 1.0; 

            // Define raw inputs
            float min_cell_v = id(${yambms_id}_min_cell_voltage).state;
            float cell_low_v = id(${yambms_id}_cell_uvp).state + 0.2;

            // Exit if critical data is missing
            if (isnan(max_current) || isnan(min_cell_v) || isnan(cell_low_v)) {
              output_id = 0.0f;
              id(${yambms_id}_var_discharge_current_step)++;
              return;
            }
          
            // Check switch enabled
            if (!id(${yambms_id}_switch_auto_dcl).state) {
              output_id = 0.0f;
              id(${yambms_id}_var_discharge_current_step)++;
              return;
            }

            // Calculate initial current delta
            double delta = 0.0;

            if (min_cell_v < cell_low_v) {
              delta = -max_current;
            } else {
              double ratio = max(0.0, ((min_cell_v - ${discharge_knee_v}) / (cell_low_v - ${discharge_knee_v})));
              double curve = pow(${discharge_a_factor_curve_end}, pow(ratio, ${discharge_a_factor_curve_shape}));
              delta = max(0.0, (-curve + 2) * max_current) - max_current;
            }

            if (!is_initialized) {
              current_output = delta;
              is_initialized = true;
            }

            // Apply decrease in current instantly      
            // This means that cell voltage decreases will be reacted to quickly
            if (delta < current_output) {
               current_output = delta;
            } 
            // Apply increase in current slowly, prevent oscillation of cell voltage
            else {
               // Calculate the gap to output
               float gap = delta - current_output;
               
               // Calculate exponential moving average
               float step = gap * alpha;
               
               // Apply minimum increase step
               // If the calculated step is tiny, force it to be at least min_amp_increase_step
               if (step < min_amp_increase_step) {
                   step = min_amp_increase_step;
               }
               
               // Calculate output
               if (step > gap) {
                   current_output = delta;
               } else {
                   current_output += step;
               }
            }

            // Update global
            current_output = round(current_output * 10) / 10.0;
            output_id = current_output;
            id(${yambms_id}_var_discharge_current_step)++;
          }
