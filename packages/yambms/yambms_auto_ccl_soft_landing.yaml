#------------------------------------------------------------------------------
# Auto CCL Soft Landing
#
# Purpose:
#   Enforce a soft landing at the bulk target by limiting charge current
#   as the target voltage is approached.
#
# Contract with yambms_core.yaml:
#   - Participates in Auto CCL STEP pipeline
#   - Writes ONLY: id(${yambms_id}_var_auto_ccl)
#   - Value must be <= 0.0  (0 = no reduction, negative = reduce)
#   - Advances pipeline via: id(${yambms_id}_var_charge_current_step)++
#------------------------------------------------------------------------------

substitutions:
  # Volts below bulk where taper begins
  charge_taper_start_offset: '2.0'

  # Max landing C-rate (A = Ah * C-rate)
  landing_c_rate: '0.30'

globals:
  - id: ${yambms_id}_auto_ccl_soft_landing_runs_count
    type: uint32_t
    restore_value: no
    initial_value: '0'

  - id: ${yambms_id}_auto_ccl_soft_landing_registered
    type: bool
    restore_value: no
    initial_value: 'false'

switch:
  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing
    id: ${yambms_id}_switch_auto_ccl_soft_landing
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config

sensor:
  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing Delta
    id: ${yambms_id}_auto_ccl_soft_landing_delta
    unit_of_measurement: A
    device_class: current
    accuracy_decimals: 1
    entity_category: diagnostic
    update_interval: never

  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing Runs
    id: ${yambms_id}_auto_ccl_soft_landing_runs
    unit_of_measurement: runs
    accuracy_decimals: 0
    entity_category: diagnostic
    update_interval: never

esphome:
  on_boot:
    priority: -100.0
    then:
      - lambda: |-
          id(${yambms_id}_var_auto_ccl_functions_count)++;
          ESP_LOGW("softland", "on_boot ran, my_step=%d",
                   id(${yambms_id}_var_auto_ccl_functions_count));

interval:
  - interval: ${yambms_update_interval}
    then:
      - lambda: |-
          // ------------------------------------------------------------
          // One-time registration (fallback if package on_boot doesn't merge)
          // ------------------------------------------------------------
          if (!id(${yambms_id}_auto_ccl_soft_landing_registered)) {
            id(${yambms_id}_var_auto_ccl_functions_count)++;  // "I am an Auto-CCL reducer"
            id(${yambms_id}_auto_ccl_soft_landing_registered) = true;
            ESP_LOGW("softland", "registered: auto_ccl_functions_count=%d",
                     id(${yambms_id}_var_auto_ccl_functions_count));
          }

          // ------------------------------------------------------------
          // STEP-2 gate (Sleeper85 scheme)
          // ------------------------------------------------------------
          const int cc_step = id(${yambms_id}_var_charge_current_step);
          const int nfunc   = id(${yambms_id}_var_auto_ccl_functions_count);

          if (cc_step < 1 || cc_step >= (nfunc + 1)) return;

          // ------------------------------------------------------------
          // Switch OFF: contribute nothing, but MUST pass the baton
          // ------------------------------------------------------------
          if (!id(${yambms_id}_switch_auto_ccl_soft_landing).state) {
            id(${yambms_id}_var_auto_ccl) = 0.0f;
            id(${yambms_id}_var_charge_current_step)++;
            return;
          }

          // Proof-of-life: enabled + scheduled
          id(${yambms_id}_auto_ccl_soft_landing_runs_count)++;
          id(${yambms_id}_auto_ccl_soft_landing_runs).publish_state(
            (float) id(${yambms_id}_auto_ccl_soft_landing_runs_count)
          );

          // ------------------------------------------------------------
          // Soft-landing math (overwrite var_auto_ccl for testing)
          // ------------------------------------------------------------
          const float pack_v  = id(${yambms_id}_total_voltage).state;
          const float bulk_v  = id(${yambms_id}_bulk_voltage).state;
          const float taper_v = ${charge_taper_start_offset};

          float delta_a = 0.0f;

          const float taper_start_v = bulk_v - taper_v;

          if (pack_v >= taper_start_v) {
            const float Ah = id(${yambms_id}_installed_battery_capacity).state;

            float I_ref = Ah * ${landing_c_rate};
            I_ref = std::min(I_ref, id(${yambms_id}_max_charge_current).state);
            I_ref = std::min(I_ref, id(${yambms_id}_max_requested_charge_current).state);

            float frac = (bulk_v - pack_v) / taper_v;
            if (frac < 0.0f) frac = 0.0f;
            if (frac > 1.0f) frac = 1.0f;

            const float target_I = I_ref * frac;

            delta_a = target_I - id(${yambms_id}_max_charge_current).state;
            if (delta_a > 0.0f) delta_a = 0.0f;
          }

          id(${yambms_id}_var_auto_ccl) = delta_a;  // test mode: overwrite
          id(${yambms_id}_auto_ccl_soft_landing_delta).publish_state(delta_a);

          // Pass the baton exactly once
          id(${yambms_id}_var_charge_current_step)++;
