#------------------------------------------------------------------------------
# Auto CCL Soft Landing
#
# Purpose:
#   Enforce a soft landing at the bulk target by limiting charge current
#   as the target voltage is approached.
#
# Contract with yambms_core.yaml:
#   - Participates in Auto CCL STEP pipeline
#   - Writes ONLY: id(${yambms_id}_var_auto_ccl)
#   - Value must be <= 0.0  (0 = no reduction, negative = reduce)
#   - Advances pipeline via: id(${yambms_id}_var_charge_current_step)++
#------------------------------------------------------------------------------

substitutions:
  # Volts below bulk where taper begins
  charge_taper_start_offset: '2.0'

  # Max landing C-rate (A = Ah * C-rate)
  landing_c_rate: '0.30'

globals:
  - id: ${yambms_id}_auto_ccl_soft_landing_runs_count
    type: uint32_t
    restore_value: no
    initial_value: '0'

  - id: ${yambms_id}_auto_ccl_soft_landing_registered
    type: bool
    restore_value: no
    initial_value: 'false'

switch:
  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing
    id: ${yambms_id}_switch_auto_ccl_soft_landing
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config

sensor:
  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing Delta
    id: ${yambms_id}_auto_ccl_soft_landing_delta
    unit_of_measurement: A
    device_class: current
    accuracy_decimals: 1
    entity_category: diagnostic
    update_interval: never

  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing Runs
    id: ${yambms_id}_auto_ccl_soft_landing_runs
    unit_of_measurement: runs
    accuracy_decimals: 0
    entity_category: diagnostic
    update_interval: never

script:
  # This is called from my yambms.yaml config file to 'register' this function with yambms.
  # esphome on_boot is unreliable. 
  - id: ${yambms_id}_auto_ccl_soft_landing_register
    mode: queued
    then:
      - lambda: |-
          if (id(${yambms_id}_auto_ccl_soft_landing_registered)) return;   // already registered
          id(${yambms_id}_auto_ccl_soft_landing_registered) = true;

          id(${yambms_id}_var_auto_ccl_functions_count)++;

          ESP_LOGW("softland",
                   "%s registered: auto_ccl_functions_count=%d",
                   "${yambms_id}",
                   id(${yambms_id}_var_auto_ccl_functions_count));

interval:
  - interval: ${yambms_update_interval}
    then:
      - lambda: |-
          const int cc_step = id(${yambms_id}_var_charge_current_step);
          const int nfunc   = id(${yambms_id}_var_auto_ccl_functions_count);

          if (cc_step < 1 || cc_step >= (nfunc + 1)) return;

          // Switch OFF: contribute nothing, but we must 'pass the baton' by incrementing the step
          if (!id(${yambms_id}_switch_auto_ccl_soft_landing).state) {
            // Disabled: do not touch shared var_auto_ccl (avoid clobbering others)
            id(${yambms_id}_var_charge_current_step)++;
            return;
          }

          // Proof-of-life: enabled + scheduled
          id(${yambms_id}_auto_ccl_soft_landing_runs_count)++;
          id(${yambms_id}_auto_ccl_soft_landing_runs).publish_state(
            (float) id(${yambms_id}_auto_ccl_soft_landing_runs_count)
          );

          // ------------------------------------------------------------
          // Soft-landing math
          // ------------------------------------------------------------
          const float pack_v  = id(${yambms_id}_total_voltage).state;   // Battery voltage
          const float bulk_v  = id(${yambms_id}_bulk_voltage).state;    // Bulk voltage (taget)
          const float taper_v = ${charge_taper_start_offset};           // Voltage offset where we start tapering

          float delta_a = 0.0f;

          const float taper_start_v = bulk_v - taper_v;                 // Voltage where we start tapering

          if (pack_v >= taper_start_v) {                                          // We're in the 'taper zone'
            const float Ah = id(${yambms_id}_installed_battery_capacity).state;   // Amps scaled to battery capacity

            float I_ref = Ah * ${landing_c_rate};                                 // This is where the taper curve starts
            I_ref = std::min(I_ref, id(${yambms_id}_max_charge_current).state);
            I_ref = std::min(I_ref, id(${yambms_id}_max_requested_charge_current).state);

            float frac = (bulk_v - pack_v) / taper_v;
            if (frac < 0.0f) frac = 0.0f;
            if (frac > 1.0f) frac = 1.0f;

            const float target_I = I_ref * frac;

            delta_a = target_I - id(${yambms_id}_max_charge_current).state;
            if (delta_a > 0.0f) delta_a = 0.0f;
          }

          id(${yambms_id}_var_auto_ccl) = delta_a;                               // Do we get our own softland global?
          id(${yambms_id}_auto_ccl_soft_landing_delta).publish_state(delta_a);   // Update the Home Assistsnt sensor

          // Pass the baton exactly once
          id(${yambms_id}_var_charge_current_step)++;
