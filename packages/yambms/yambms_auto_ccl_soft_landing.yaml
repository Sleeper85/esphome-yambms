#------------------------------------------------------------------------------
# Auto CCL Soft Landing
#
# Purpose:
#   Enforce a soft landing at the bulk target by limiting charge current
#   as the target voltage is approached.
#
# Contract with yambms_core.yaml:
#   - Participates in Auto CCL STEP pipeline
#   - Writes ONLY: id(${yambms_id}_var_auto_ccl)
#   - Value must be <= 0.0  (0 = no reduction, negative = reduce)
#   - Advances pipeline via: id(${yambms_id}_var_charge_current_step)++
#------------------------------------------------------------------------------

substitutions:
  # Volts below bulk where taper begins
  charge_taper_start_offset: '2.0'

  # Max landing C-rate (A = Ah * C-rate)
  landing_c_rate: '0.30'

globals:
  # Our assigned STEP index within the Auto CCL pipeline
  - id: ${yambms_id}_auto_ccl_soft_landing_step
    type: int
    restore_value: no
    initial_value: '0'

  # This just tells me it's running - can comment out after verifying
  - id: ${yambms_id}_auto_ccl_soft_landing_runs_count
    type: uint32_t
    restore_value: no
    initial_value: '0'

switch:
  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing
    id: ${yambms_id}_switch_auto_ccl_soft_landing
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config

sensor:
  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing Delta
    id: ${yambms_id}_auto_ccl_soft_landing_delta
    unit_of_measurement: A
    device_class: current
    accuracy_decimals: 1
    entity_category: diagnostic
    update_interval: never

  - platform: template
    name: ${name} ${yambms_name} Auto CCL Soft Landing Runs
    id: ${yambms_id}_auto_ccl_soft_landing_runs
    unit_of_measurement: runs
    accuracy_decimals: 0
    entity_category: diagnostic
    update_interval: never

esphome:
  on_boot:
    priority: 600
    then:
      - lambda: |-
          // Claim one slot in the Auto CCL function chain.
          // Core will execute steps 1..N, then compute Requested CCL at N+1.
          id(${yambms_id}_var_auto_ccl_functions_count)++;
          id(${yambms_id}_auto_ccl_soft_landing_step) =
            id(${yambms_id}_var_auto_ccl_functions_count);

interval:
  - interval: ${yambms_update_interval}
    then:
      - lambda: |-
          // Only run on our assigned STEP
          const int cc_step = id(${yambms_id}_var_charge_current_step);
          if (cc_step != id(${yambms_id}_auto_ccl_soft_landing_step)) return;

          // Disabled => no derate
          if (!id(${yambms_id}_switch_auto_ccl_soft_landing).state) {
            id(${yambms_id}_var_auto_ccl) = 0.0f;
            id(${yambms_id}_var_charge_current_step)++;
            return;
          }

          // Proof-of-life: this module executed its STEP
          id(${yambms_id}_auto_ccl_soft_landing_runs_count)++;
          id(${yambms_id}_auto_ccl_soft_landing_runs).publish_state(
            (float) id(${yambms_id}_auto_ccl_soft_landing_runs_count)
          );

          // Inputs
          const float pack_v = id(${yambms_id}_total_voltage).state;   // Battery Voltage
          const float bulk_v = id(${yambms_id}_bulk_voltage).state;    // Bulk Voltage (target)
          const float taper_v = ${charge_taper_start_offset};
          const float taper_start_v = bulk_v - taper_v;

          // Outside landing window => no derate
          if (pack_v < taper_start_v) {
            id(${yambms_id}_var_auto_ccl) = 0.0f;
            id(${yambms_id}_var_charge_current_step)++;
            return;
          }

          const float Ah = id(${yambms_id}_installed_battery_capacity).state;

          // Reference current for landing curve (A), clamped
          float I_ref = Ah * ${landing_c_rate};
          I_ref = std::min(I_ref, id(${yambms_id}_max_charge_current).state);
          I_ref = std::min(I_ref, id(${yambms_id}_max_requested_charge_current).state);

          // Linear landing: full at taper_start_v, zero at bulk_v
          float frac = (bulk_v - pack_v) / taper_v;
          if (frac < 0.0f) frac = 0.0f;
          if (frac > 1.0f) frac = 1.0f;

          const float target_I = I_ref * frac;

          // Delta (<= 0): negative reduces allowed current
          float delta_a = target_I - id(${yambms_id}_max_charge_current).state;
          if (delta_a > 0.0f) delta_a = 0.0f;

          // Publish contribution for core combiner
          id(${yambms_id}_var_auto_ccl) = delta_a;
          id(${yambms_id}_auto_ccl_soft_landing_delta).publish_state(delta_a);

          // Advance pipeline
          id(${yambms_id}_var_charge_current_step)++;
