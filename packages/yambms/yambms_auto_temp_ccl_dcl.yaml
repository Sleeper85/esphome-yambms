# Updated : 2026.02.02
# Version : 1.1.3
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

# +-------------------------------------------------------------------------+
# | Temperature-based current limitation                                    |
# | Can be disabled via the switch "Temperature-based current limitation"   |
# | This factor is applied to the battery capacity (Ah), not the current    |
# | maximum charge/discharge current. For example : 280Ah x 0.5 = 140A      |
# +-------------------------------------------------------------------------+

esphome:
  on_boot:
    priority: -100.0
    then:
      - lambda: |-
          id(${yambms_id}_var_auto_ccl_functions_count)++;
          id(${yambms_id}_var_auto_dcl_functions_count)++;

globals:
  - id: charging_table
    type: std::map<float, float>
    initial_value: '${yambms_charging_rate_table}'

  - id: discharging_table
    type: std::map<float, float>
    initial_value: '${yambms_discharging_rate_table}'

switch:
  - platform: template
    name: "${name} ${yambms_name} Temperature-based Current Limitation"
    id: ${yambms_id}_switch_temperature_based_current_limitation
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: config

interval:
  - interval: ${yambms_update_interval}
    then:
      # +------------------------------------------+
      # | Auto Temperature CCL                     |
      # +------------------------------------------+
      - lambda: |-
          int cc_step = id(${yambms_id}_var_charge_current_step);
          if (cc_step >= 1 && cc_step < id(${yambms_id}_var_auto_ccl_functions_count) + 1)
          {
            ESP_LOGD("yambms_debug", "Entering Auto Temp. CCL...");

            // Configuration
            auto& rate_table   = id(charging_table);
            float max_current  = id(${yambms_id}_max_charge_current).state;
            auto& output_id    = id(${yambms_id}_var_auto_temperature_ccl);
            float alpha        = 0.05f;

            // Check switch enabled
            if (!id(${yambms_id}_switch_temperature_based_current_limitation).state) {
              output_id = 0.0f;
              id(${yambms_id}_var_charge_current_step)++;
              return;
            }

            // Define raw inputs
            float raw_min = id(${yambms_id}_min_temperature).state;
            float raw_max = id(${yambms_id}_max_temperature).state;
            float batt_capacity = id(${yambms_id}_battery_capacity).state;

            // Exit if critical data is missing
            if (isnan(raw_min) || isnan(raw_max) || isnan(batt_capacity)) {
              output_id = 0.0f;
              id(${yambms_id}_var_charge_current_step)++;
              return;
            }

            // Setup static variables
            static float s_min_temp = NAN;
            static float s_max_temp = NAN;

            // Instantly match sensor if first run or if temperature changes by > 5°C
            if (isnan(s_min_temp) || std::abs(raw_min - s_min_temp) > 5.0f || std::abs(raw_max - s_max_temp) > 5.0f) {
              s_min_temp = raw_min;
              s_max_temp = raw_max;
            } else {
              // Apply smoothing only when data is stable
              s_min_temp = (alpha * raw_min) + (1.0f - alpha) * s_min_temp;
              s_max_temp = (alpha * raw_max) + (1.0f - alpha) * s_max_temp;
            }

            // Interpolation function
            auto interpolate = [](const std::map<float, float>& m, float x) -> float {
              if (m.empty()) return 0.0f;
              if (x <= m.begin()->first) return m.begin()->second;
              if (x >= m.rbegin()->first) return m.rbegin()->second;
              auto it_upper = m.upper_bound(x);
              auto it_lower = std::prev(it_upper);
              float x0 = it_lower->first, y0 = it_lower->second;
              float x1 = it_upper->first, y1 = it_upper->second;
              return y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
            };

            // Determine high and low C-rate
            float rate_low = interpolate(rate_table, s_min_temp);
            float rate_high = interpolate(rate_table, s_max_temp);
            float allowed_rate = std::min(rate_low, rate_high);

            float target_current = allowed_rate * batt_capacity;
            float delta = target_current - max_current;

            // Current can only be reduced
            if (delta > 0.0f) delta = 0.0f;
            delta = roundf(delta * 10.0f) / 10.0f;

            // Update global
            output_id = delta;
            id(${yambms_id}_var_charge_current_step)++;
          }

      # +------------------------------------------+
      # | Auto Temperature DCL                     |
      # +------------------------------------------+
      - lambda: |-
          int dc_step = id(${yambms_id}_var_discharge_current_step);
          if (dc_step >= 1 && dc_step < id(${yambms_id}_var_auto_dcl_functions_count) + 1)
          {
            ESP_LOGD("yambms_debug", "Entering Auto Temp. DCL...");

            // Configuration
            auto& rate_table   = id(discharging_table);
            float max_current  = id(${yambms_id}_max_discharge_current).state;
            auto& output_id    = id(${yambms_id}_var_auto_temperature_dcl);
            float alpha        = 0.05f;

            // Check switch enabled
            if (!id(${yambms_id}_switch_temperature_based_current_limitation).state) {
              output_id = 0.0f;
              id(${yambms_id}_var_discharge_current_step)++;
              return;
            }

            // Define raw inputs
            float raw_min = id(${yambms_id}_min_temperature).state;
            float raw_max = id(${yambms_id}_max_temperature).state;
            float batt_capacity = id(${yambms_id}_battery_capacity).state;

            // Exit if critical data is missing
            if (isnan(raw_min) || isnan(raw_max) || isnan(batt_capacity)) {
              output_id = 0.0f;
              id(${yambms_id}_var_discharge_current_step)++;
              return;
            }

            // Setup static variables
            static float s_min_temp = NAN;
            static float s_max_temp = NAN;

            // Instantly match sensor if first run or if temperature changes by > 5°C
            if (isnan(s_min_temp) || std::abs(raw_min - s_min_temp) > 5.0f || std::abs(raw_max - s_max_temp) > 5.0f) {
              s_min_temp = raw_min;
              s_max_temp = raw_max;
            } else {
              // Apply smoothing only when data is stable
              s_min_temp = (alpha * raw_min) + (1.0f - alpha) * s_min_temp;
              s_max_temp = (alpha * raw_max) + (1.0f - alpha) * s_max_temp;
            }

            // Interpolation function
            auto interpolate = [](const std::map<float, float>& m, float x) -> float {
              if (m.empty()) return 0.0f;
              if (x <= m.begin()->first) return m.begin()->second;
              if (x >= m.rbegin()->first) return m.rbegin()->second;
              auto it_upper = m.upper_bound(x);
              auto it_lower = std::prev(it_upper);
              float x0 = it_lower->first, y0 = it_lower->second;
              float x1 = it_upper->first, y1 = it_upper->second;
              return y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
            };

            // Determine high and low C-rate
            float rate_low = interpolate(rate_table, s_min_temp);
            float rate_high = interpolate(rate_table, s_max_temp);
            float allowed_rate = std::min(rate_low, rate_high);

            float target_current = allowed_rate * batt_capacity;
            float delta = target_current - max_current;

            // Current can only be reduced
            if (delta > 0.0f) delta = 0.0f;
            delta = roundf(delta * 10.0f) / 10.0f;

            // Update global
            output_id = delta;
            id(${yambms_id}_var_discharge_current_step)++;
          }
